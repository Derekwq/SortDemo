# SortDemo
在开发者头条上看到一篇关于各种排序算法的总结，刚好近期闲来无事，就用Java重新整理了一遍。


## 冒泡排序
### 原理
两两比较相邻记录的排序码，若发生逆序，则交换；

### 性能
时间复杂度为O(N^2)，空间复杂度为O(1).排序是稳定的，排序比较次数与初始序列无关，但交换次数与初始序列有关。

### 优化
若初始序列就是排序好的，对于冒泡排序仍然还要比较O(N^2)次，但无交换次数。可根据这个进行优化，设置一个flag，当在一趟序列中没有发生交换，则该序列已排序号，但优化后的排序时间复杂度没有发生量级的改变。


## 插入排序
### 原理
依次选择一个待排序的数据，插入到前边已排好序的序列中。

### 性能
时间复杂度为O(N^2)，空间复杂度为O(1)。算法是稳定的，比较次数和交换次数都与初始序列有关。

### 优化
直接插入排序每次往前插入时，是按顺序依次汪倩找，可在这里进行优化，往前找合适的插入位置时采用二分查找的方式，即折半插入。
折半插入排序相对于直接插入排序而言：平均性能更快，时间复杂度降至O(NlogN)，排序是稳定的，但排序的比较次数与初始序列无关。

### 使用场景
当数据基本有序时，采用插入排序可以明显减少数据交换和数据移动次数，进而提升排序效率。


## 希尔排序
### 原理

### 性能



## 选择排序
### 原理

### 性能


## 快速排序
### 原理

### 性能

### 优化


## 归并排序
### 原理

### 性能

### 优化


## 堆排序
### 原理

### 性能

### 使用场景


## 计数排序
### 原理

### 性能

### 使用场景


## 桶排序
### 原理

### 性能

### 使用场景


## 基数排序
### 原理

### 性能


## 总结
























